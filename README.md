This repository contains all the small openGL project that I made (which are inspired by the book superbible sixth edition).

The basic source code is taken from [Tomasz Ga≈Çaj](https://shot511.github.io/) with some modification made by myself to able multi projects.

# GL1_BasicPoint

A basic project to draw a single point or a single triangle with OpenGL.

## How to do this ?

  * **Include a window library**, we are using GLFW3 for our project but SDL2 can works too.
  * **Initialize the window**, depending of the library, the window can be initialize differently. Don't forget to add the background color of the window with **glClearColor** and the size of the **Viewport**
  * **Create your program** with **glCreateProgram**
  * **Add the different shaders**
    * shader_source code  
    * shader_type with GL_*SHADERNAME*_SHADER with *SHADERNAME* :
      * GL_VERTEX_SHADER
      * GL_FRAGMENT_SHADER
      * GL_GEOMETRY_SHADER
      * GL_TESS_CONTROL_SHADER
      * GL_TESS_EVALUATION_SHADER
    * Create your shader_object with **glCreateShader(shader_type)**
    * Link the shader_source code to your shader_object with **glShaderSource(shader_source, 1, shader_object, nullptr)**
    * Compile the shader with **glCompileShader(shader_object)**
    * Attach the shader to your program with **glAttachShader**
    * Once the shader attached to the program, you can delete it with **glDelete**
  * Don't forget to create a **V**ertex **A**rray **O**bject with **glGenVertexArrays(1 , &vao)** and to bind on it with **glBindVertexArray(vao)** when you want to use it.
  * Finally, link the program that you want with **glLinkProgram** then use it with **glUseProgram**
  * Now you can draw with the function **glDrawArrays** in the runloop which can display elements such as
    * points with **GL_POINTS**
    * triangles with **GL_TRIANGLES**
    * quads with **GL_QUADS**
    * patches with **GL_PATCHES**
  
The project use a vertex shader and a fragment shader.


# GL2_AllShaders

  The second project present the different shader possibles which was introduce in the previous project under the term *SHADERNAME*, it follows the basic pipeline used by opengl.

![pipeline](https://user-images.githubusercontent.com/45456710/94941030-9f78bd00-04d4-11eb-8315-c3f34b7dd3f5.png)

### Vertex Shader

  Vertex shaders are run once for each vertex given to the graphics processor. The purpose is to transform each vertex's 3D position in virtual space to the 2D coordinate at which it appears on the screen (as well as a depth value for the Z-buffer). Vertex shaders cannot create new vertices. The output of the vertex shader goes to the next stage in the pipeline, which is either a tesselation shader (since OpenGL 4.0), either a geometry shader if present, or the rasterizer.

### Tesselation (OpenGL 4.0)

  As of OpenGL 4.0 and Direct3D 11, a new shader class called a tessellation shader has been added. It adds two new shader stages to the traditional model: **Tessellation Control Shaders (also known as hull shaders)** and **Tessellation Evaluation Shaders (also known as Domain Shaders)**, which together allow for simpler meshes to be subdivided into finer meshes at run-time according to a mathematical function. 

  <img src="https://user-images.githubusercontent.com/45456710/94935905-e8794300-04cd-11eb-8db4-c5558faccbaf.png" width="600" height="300" />
  <img src="https://user-images.githubusercontent.com/45456710/94937972-91c13880-04d0-11eb-9e1a-f86a883a35d9.png" width="600" height="300" />

 #### Tesselation Control Shader (TCS)

  The TCS controls how much tessellation a particular patch gets and it also defines the size of a patch.

  ![SubdivideEqual](https://user-images.githubusercontent.com/45456710/94938996-d13c5480-04d1-11eb-9bea-c015627dbbde.gif)

 #### Tesselation Evaluation Shader (TES)
 
  The TES takes the abstract patch generated by the tessellation primitive generation stage, and generates a particular vertex from it.

### Geometry Shader (OpenGL 3.2 or OpenGL 2.0+ with extensions)

  Geometry take as input a whole primitive, possibly with adjacency information. For example, when operating on triangles, the three vertices are the geometry shader's input. The shader can then emit zero or more primitives, which are rasterized and their fragments ultimately passed to a pixel shader.

  Typical uses of a geometry shader include point sprite generation, geometry tessellation, shadow volume extrusion, and single pass rendering to a cube map. A good example could be a series of line strips representing control points for a curve are passed to the geometry shader and depending on the complexity required the shader can automatically generate extra lines each of which provides a better approximation of a curve.

### Fragment Shader

  A Fragment Shader is the Shader stage that will process a Fragment generated by the Rasterization into a set of colors and a single depth value.

A quick diagram to summarize the diffents shaders and actions into the pipeline.

![OpenGlCoreTutorial_pipeline](https://user-images.githubusercontent.com/45456710/94934893-9683ed80-04cc-11eb-8588-54a0e807faf8.png)

There is a lot of undisclosed action in the pipeline like the clipping, the culling or the rasterization. 
